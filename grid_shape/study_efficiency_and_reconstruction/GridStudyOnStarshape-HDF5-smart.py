'''
Count triggered antennas for one shower, for a set of layouts
Performs an interpolation of the traces of the peak-to-peak electric field/voltage/filtered voltage
at new layout antenna positions

IMPORTANT: THE SCRIPT HAS hard coded locations for the input files, and the reconstruction routines. 
Be sure to adapt them to your syste (search for ""/home/" on this file to see where you need to make changes)

'''

#!/usr/bin/env python
import sys
import os
import logging
import glob
import numpy as np
import subprocess
ZHAIRESRUNNER = os.environ["ZHAIRESRUNNER"]
sys.path.append(ZHAIRESRUNNER + "/ConicalInterpolator") #so that it knows where to find things
from StarshapeInterpolation import do_interpolation_hdf5
ZHAIRESPYTHON = os.environ["ZHAIRESPYTHON"]
sys.path.append(ZHAIRESPYTHON)
import hdf5fileinout as hdf5io
import AiresInfoFunctions as AiresInfo
sys.path.append("/home/mjtueros/GRAND/LayoutStudy/GridShapeKotera/GRAND_tools/grid_shape")
import grids
from mpl_toolkits import mplot3d
import matplotlib.pyplot as plt

ArrayCenter = (5000,7742.8) #for big area generated by kewen
ArrayCenter = (3400,4800) #for GP100 array generated by kewen

retries = 1000

minefield = 66 #*5/(3*40) #[uv/m]anennas with amplitude below will not be saved (voltage and efield must be above to pass the criteria. This is becouse the unfiltered electric field is not reliable as a threshold in my opinion)
minvoltage = 45 #*5/(3*40) #[uV] anennas with amplitude below will not be saved

siteradius = 5250 #controls the radius of the array circular area drawn on the plots

antennathreshold = 5 #controls the T2 antenna threshold (events neead to have this or more antennas to be considered)

reconstructiontrace = "voltage" #the reconstruction is still not capable of running several trace types at the same time, so you have to set it manually here

plt.rc('font', family = 'serif', size = 18)
width = 7.2
height = width/1.45  


def grid_study_on_starshape_hdf5(InputDir, OutputDir, configurations,  usetrace = 'efield'):
    DISPLAY = False
    OLDOUTPUT = False
    RECONSTRUCT = 3 #(0 no rec, 1 plane, 2 plane + sphere, 3 plane + sphere + adf)
    SAVETRACES = False

    if(not ".hdf5" in InputDir):
        #we open any hdf5 file looking for the JobName, hoping we will find it...
        hdf5file = glob.glob(InputDir+"/*.hdf5")[0]
        head,tail = os.path.split(hdf5file)
        print('Any hdf5file',hdf5file)
        InputFileName = hdf5file.split(".hdf5")    
        InputFileName = InputFileName[0]+str(".hdf5")
        #print("Starting grid_study_on_starshape on ",InputFileName)
        AnyRunInfo = hdf5io.GetRunInfo(InputFileName)
        AnyEventName = hdf5io.GetEventName(AnyRunInfo, 0)  # using the first event of each file (there is only one for now)
        InputJobName = AnyEventName
        InputFileName = head+"/"+InputJobName+str(".hdf5")
    else:
        InputFileName = InputDir
      
    if not os.path.exists(OutputDir):
        os.makedirs(OutputDir)
        logging.debug("Output Dir Exists already:"+OutputDir)        
    else:
        logging.debug("Output Dir Exists already:"+OutputDir)  
      

    print("Starting grid_study_on_starshape on ",InputFileName)   
    #get basic showerinfo we will output to the showerinfo file
    CurrentRunInfo = hdf5io.GetRunInfo(InputFileName)
    CurrentEventName = hdf5io.GetEventName(CurrentRunInfo,0) #using the first event of each file (there is only one for now)
    CurrentEventInfo = hdf5io.GetEventInfo(InputFileName,CurrentEventName)
    CurrentAntennaInfo = hdf5io.GetAntennaInfo(InputFileName,CurrentEventName)
    CurrentAntennaP2PInfo = hdf5io.GetAntennaP2PInfo(InputFileName,CurrentEventName)


    Zenith = hdf5io.GetEventZenith(CurrentRunInfo,0)
    Azimuth = hdf5io.GetEventAzimuth(CurrentRunInfo,0)
    Primary = hdf5io.GetEventPrimary(CurrentRunInfo,0)
    Energy = hdf5io.GetEventEnergy(CurrentRunInfo,0)
    XmaxDistance = hdf5io.GetEventXmaxDistance(CurrentRunInfo,0)
    GroundAltitude = hdf5io.GetGroundAltitude(CurrentEventInfo)
    SlantXmax = hdf5io.GetEventSlantXmax(CurrentRunInfo,0)
    HadronicModel = hdf5io.GetEventHadronicModel(CurrentRunInfo,0)
    RandomAzimuth = np.random.uniform(0,360)

    CurrentSignalSimInfo = hdf5io.GetSignalSimInfo(InputFileName,CurrentEventName)
    Indexparameters = hdf5io.GetRefractionIndexModelParameters(CurrentSignalSimInfo)
    XmaxPosition = hdf5io.GetXmaxPosition(CurrentEventInfo).data[0]
    xXmax = XmaxPosition[0]
    yXmax = XmaxPosition[1]
    zXmax = XmaxPosition[2]
    ns = (Indexparameters[0]-1)*1E6
    kr = Indexparameters[1]

    #Get stshp antenna positions,time and amplitudes
    StshpX = hdf5io.GetXFromAntennaInfo(CurrentAntennaInfo)
    StshpY = hdf5io.GetYFromAntennaInfo(CurrentAntennaInfo)
    StshpZ = hdf5io.GetZFromAntennaInfo(CurrentAntennaInfo)
    T0s = hdf5io.GetAntennaT0s(CurrentAntennaInfo)
    
    PeakE = hdf5io.GetHilbertPeakEFromAntennaP2PInfo(CurrentAntennaP2PInfo)
    PeakV = hdf5io.GetHilbertPeakVFromAntennaP2PInfo(CurrentAntennaP2PInfo)
    PeakE = PeakE.data
    PeakV = PeakV.data #to make it an array
    
    cspeed = 299792458.0 #m/x
    time2core = XmaxDistance/cspeed          
          
    #RandomAzimuth = 30
    print("Using Random Azimuth for rotation",RandomAzimuth)
    EmulatedAzimuth = Azimuth-RandomAzimuth
    if(EmulatedAzimuth<0):
      EmulatedAzimuth = EmulatedAzimuth+360
    print("Resulting in an Emulated Azimuth",EmulatedAzimuth)
    
    for case in configurations:
        gridtype = case[0]
        step = case[1]
        nrings = case[2]
        
        if(gridtype =  = "GP100"):
          step =  5750/np.cos((180-Zenith)*np.pi/180.0)
          print("step",step,"Zenith",180-Zenith)
        OutputFileName =  OutputDir+"/"+CurrentEventName + ".Interpolated."+gridtype+"_"+str(usetrace)+"_"+str(EmulatedAzimuth)+".hdf5"


        if os.path.isfile(OutputFileName):
          print(OutputFileName+" exists,... it shouldnt")
          return
          #os.remove(OutputFileName)
          #continue
        
        print("Processing Configuration: GridType:"+gridtype+" Step:"+str(step))      
        
        weight = 0
        found = False
        CoresTested = []
        while(not found and weight<retries):
         #This will create the antenna positions rotated and displaced to simulate a different incoming azimuth for the reference shower and a different core position (given by RandomCore, in array cenetered coordinates).
          #The interpolation then takes care to put it back in the shower reference frame is
          #Positions are centered on the core position, which is given by RandomCore relative to the FTP
          # RotatedDesPos,RandomCoreAC = grids.create_grid_univ(gridtype,step,RandomAzimuth,do_offset = False,DISPLAY = DISPLAY,input_n_ring = nrings,directory = ".") #no offset for tests         
          RotatedDesPos,RandomCoreAC = grids.create_grid_univ(gridtype,step,RandomAzimuth,do_offset = True,DISPLAY = DISPLAY,input_n_ring = nrings,directory = ".")
          weight+ = 1
          
          RandomCoreFTP = [0,0,0]
          RandomCoreFTP[0] = RandomCoreAC[0] + ArrayCenter[0]
          RandomCoreFTP[1] = RandomCoreAC[1] + ArrayCenter[1]   #move it to ftp centered
          CoresTested.append(RandomCoreFTP)
                 
          #i use dummy to store the Positions as they will be used on the interpolation, and condition it for later use in the interpolation. Dont Change it!
          Dummy =  np.zeros((len(RotatedDesPos.T),4))
          Dummy[:,0:3] =  RotatedDesPos.T
          
          #Now, i will start working on getting only events that have some chance of being triggered
          
          RotatedDesX = Dummy[:,0]
          RotatedDesY = Dummy[:,1]
          RotatedDesZ = Dummy[:,2]
          DesT0 = Dummy[:,3]

          #now, i will rotate the desired positions to put them back to a core cetered coordinate system 
          theta = RandomAzimuth / 180 * np.pi
          #first, i have to displace them back to be on the center of the array. since the displacement was done with the rotation, i have to first rotate the core position
          RotatedRandomCoreAC = [0,0,0]
          RotatedRandomCoreAC[0] = RandomCoreAC[0]*np.cos(theta)- RandomCoreAC[1]*np.sin(theta)  
          RotatedRandomCoreAC[1] = RandomCoreAC[0]*np.sin(theta)+ RandomCoreAC[1]*np.cos(theta)

          RotatedDesX = (RotatedDesX + RotatedRandomCoreAC[0])
          RotatedDesY = (RotatedDesY + RotatedRandomCoreAC[1])
          
          #now that i have the positions relative to the center off the array, i can unrotate them, and they will be in the array centered coordinates
          DesXAC = (RotatedDesX)*np.cos(-theta)- (RotatedDesY)*np.sin(-theta)
          DesYAC = (RotatedDesX)*np.sin(-theta)+ (RotatedDesY)*np.cos(-theta)
          
          ##and now i express them relative to the core position
          DesXCC = DesXAC-RandomCoreAC[0]
          DesYCC = DesYAC-RandomCoreAC[1]
          
          #The starshape is always core centered, but im emulating a rotated event, so equivalently i unrotate the starshape  
          RotatedStshpX = StshpX*np.cos(-theta)- StshpY*np.sin(-theta)  
          RotatedStshpY = StshpX*np.sin(-theta)+ StshpY*np.cos(-theta)

          #now, lets find where we have triggering antennas in the starshapr
          #antennas above threshold
          Stshp_trigE = np.where(PeakE[0:160]>minefield)          
          Stshp_trigV = np.where(PeakV[0:160]>minvoltage)
          #antennas with both triggers 
          Stshp_trig_both = np.intersect1d(Stshp_trigE,Stshp_trigV)              
          nStshp_trig_both = np.shape(Stshp_trig_both)[0]
          if nStshp_trig_both =  = 0:
            max_triggered_ant = 0
          else:
            max_triggered_ant = np.max(Stshp_trig_both) #max_triggered_ant is the biggest antenna number triggered. Since the antenna pattern numbering is a spiral, this will also be one of the fartehr away antennas 

          #we ask that at least 4 are above threshold (or the interpolation will never be above threshold, ans we ask that the farthest away triggered antenna is on generation 2 (so, antenna 8 or more))
          #this avoids the problem of having the only triggered antennas to be on the "inner" circle, which gives a very crappy intrpolation makin all the inside basiclly equal to the inner circle
          #(one idea might be to consider putting an antenna on the center and interpolate with that...but needs to be tested and i doubt it will work) 
          if(nStshp_trig_both>3 and max_triggered_ant>7):
            #now, since the starshape has 8 arms, and antennas are numbered in spiral, if i divide by 8 the antenna number i get the "generation". I peak the farther away antenna
            genmax = np.floor_divide(max_triggered_ant,8)
                                    
            # Extract x coords and y coords of the farthest triggered ellipse as column vectors. The starshape is always centered on the core
            X = RotatedStshpX[8*genmax:8*(genmax+1)].data
            Y = RotatedStshpY[8*genmax:8*(genmax+1)].data
            #print(genmax)             
            X = X.reshape((-1, 1))
            Y = Y.reshape((-1, 1))
              
            #fit an elipse   
            #https://stackoverflow.com/questions/47873759/how-to-fit-a-2d-ellipse-to-given-points
            # Formulate and solve the least squares problem ||Ax - b ||^2
            A = np.hstack([X**2, X * Y, Y**2, X, Y])
            b = np.ones_like(X)
            x = np.linalg.lstsq(A, b,rcond = None)[0].squeeze()

            # Print the equation of the ellipse in standard form
            #print('The ellipse is given by {0:.3}x^2 + {1:.3}xy+{2:.3}y^2+{3:.3}x+{4:.3}y = 1'.format(x[0], x[1],x[2],x[3],x[4]))
              
            elipse = x[0] * DesXCC ** 2 + x[1] * DesXCC * DesYCC + x[2] * DesYCC**2 + x[3] * DesXCC + x[4] * DesYCC

            #number of antennas inside the elipse
            nantennas_in = np.count_nonzero(elipse < 1)
            antennas_in = np.where(elipse<1)[0]
            #print("antennas inside the usefull part of the starshape",antennas_in,np.shape(antennas_in))

            if(nantennas_in> = antennathreshold):
              found = True
              weight = 1/weight #the inverse of the number of trials
              print("weight",weight)
              
          else:   
            print("no antenna on the footprint is above the threshold, its not necessary to continue") #this would be better if stored in hdf5, copying the original event information, the emulated azimuth, etc
            with open(OutputFileName[:-5]+".toolow.txt", 'w') as f:
                f.write('#no antenna on the footprint is above the threshold, nothing to be done\n')
                f.close()                                              
            sys.exit()
        #end while                  
        if(not found):
          print("we could not find one core triggering even if we tried this many cores",retries) #this would be better if stored in hdf5, copying the original event information, the emulated azimuth, etc
          CoresTested = np.array(CoresTested)
          np.savetxt(OutputFileName[:-5]+".notrigger.txt",CoresTested)
          #with open(OutputFileName[:-5]+".notrigger.txt", 'w') as f:
          #      f.write('#we could not find one core triggering even if we tried this many cores\n')
          #      content = str(CoresTested)
          #      f.write(content)
          #      f.close()                              
          sys.exit()          
                
        i = 0
        
        #Getting the T0 of the desired positions (note thay this is done on the original xmax position and the rotated positions on purpose)
        print("time2core",time2core)
        for antpos in RotatedDesPos.T:
                  
          #compute the refraction index for the time to the unrotated xmax (becouse we are doing the sim on the original shower coordinate, and only after the simulation is finished we rotate the coordinates)
          neff = AiresInfo.GetZHSEffectiveRefractionIndex(xXmax,yXmax,zXmax,xant = antpos[0],yant = antpos[1],zant = antpos[2],ns = ns,kr = kr)
          distance2ant = np.sqrt((xXmax-antpos[0])*(xXmax-antpos[0])+(yXmax-antpos[1])*(yXmax-antpos[1])+(zXmax-antpos[2])*(zXmax-antpos[2]))
          dtna = (-time2core+distance2ant*neff/cspeed)*1e9
          Dummy[i,3] = dtna
          i = i+1
          
        #Now The interpolation requests the T0 of the antennas.
        RotatedDesPos = Dummy
      
        ################################
        #Plot to check and develop
        #################################
        if(DISPLAY):
            print("RotatedDesPos shapes",np.shape(RotatedDesPos),"T0",np.shape(T0s),np.shape(XmaxPosition))
            print("RandomCoreAC",RandomCoreAC) 
            print("RandomCoreFTP",RandomCoreFTP)        
            print("XmaxPosition",XmaxPosition,xXmax,yXmax) 
            print("RandomAzimuth:",RandomAzimuth, "original azimuth",Azimuth,"so emulated azimuth",EmulatedAzimuth) #in this version all will share the same azimuth, which is more desirable. However, they will have a different Random core position             

            #FTP coodinates (in core coordinates for plot). If the RandomCore is FTP coordinates, the ftp coordinates in core cordinates is just -random core!
            Xp = -RandomCoreFTP[0]
            Yp = -RandomCoreFTP[1]

            #coordinates of the center of the array (cc in core coordinates for plot)
            Xc = Xp + ArrayCenter[0]
            Yc = Yp + ArrayCenter[1]          

            #as i rotate the antennas to simulate a different Azimuth, this would be the effctive XmaxPosition (but i still use the original xmax to compute timings becouse on the interpolation we use the desired antenas rotated)
            theta = RandomAzimuth / 180 * np.pi 
            RotatedXmaxPosition = XmaxPosition
            RotatedXmaxPosition[0] = xXmax*np.cos(-theta)- yXmax*np.sin(-theta)
            RotatedXmaxPosition[1] = xXmax*np.sin(-theta)+ yXmax*np.cos(-theta)
            print("Rotated Xmax",RotatedXmaxPosition)            
                                           
            #CurrentAntennaP2PInfo = hdf5io.GetAntennaP2PInfo(InputFileName,CurrentEventName,compute = True)
            #P2P = hdf5io.GetP2P_voltageFromAntennaP2PInfo(CurrentAntennaP2PInfo)
            #print(DesX,DesT0)

            #print(insidePoints)
            #print(np.shape(insidePoints))
            #print(insidePoints[0])
    
            fig1 = plt.figure(1,figsize = (width,height), facecolor = 'w', edgecolor = 'k')
            ax1 = fig1.add_subplot(111)
            ax1.scatter(DesXCC,DesYCC,c = DesT0,cmap = plt.cm.jet,vmin = minvoltage,vmax = np.max(T0s[0:160]),s = 150)
            ax1.scatter(RotatedStshpX[0:160],RotatedStshpY[0:160],c = np.log10(PeakV[0:160]),cmap = plt.cm.jet,vmin = np.log10(minvoltage),vmax = np.log10(np.max(PeakV[0:160])))
            ax1.plot(RotatedStshpX[8*genmax:8*(genmax+1)+1],RotatedStshpY[8*genmax:8*(genmax+1)+1])
            ax1.scatter(0,0,c = "black",label = "Core")        


            # label selected antennas
            for n in np.arange(0,nantennas_in):
              label = str(antennas_in[n])
              plt.annotate(label, # this is the text
                           (DesXCC[antennas_in[n]],DesYCC[antennas_in[n]]), # these are the coordinates to position the label
                            textcoords = "offset points", # how to position the text
                            xytext = (0,10), # distance from text to points (x,y)
                            ha = 'center') # horizontal alignment can be left, right or center)


            # label starshape points
            #for n in np.arange(0,160):
            #  label = str(n)
            #  plt.annotate(label, # this is the text
            #               (RotatedStshpX[n],RotatedStshpY[n]), # these are the coordinates to position the label
            #                textcoords = "offset points", # how to position the text
            #                xytext = (0,10), # distance from text to points (x,y)
            #                ha = 'center') # horizontal alignment can be left, right or center)

            ax1.scatter(RotatedXmaxPosition[0],RotatedXmaxPosition[1],c = 'black')
            ax1.text(RotatedXmaxPosition[0],RotatedXmaxPosition[1],"Xmax")
            
            circle2 = plt.Circle((Xc, Yc), siteradius, color = 'green',alpha = 0.25)
            
            ax1.add_patch(circle2) 
           
            ax1.plot([0,10000*np.cos((EmulatedAzimuth-180)*np.pi/180)],[0,10000*np.sin((EmulatedAzimuth-180)*np.pi/180)],'b')
            
            ax1.set_xlabel("X core centered coordinates [m] ")
            ax1.set_ylabel("Y core centered coordinates [m] ")
            
            ax1.scatter(Xp,Yp,color = 'Black',label = "FTP")
            ax1.text(Xp,Yp,"FTP")

            ax1.scatter(Xc,Yc,color = 'Black',label = "Center")
            ax1.text(Xc,Yc,"Center")

            ax1.scatter(RotatedXmaxPosition[0],RotatedXmaxPosition[1],c = 'black')
            ax1.text(RotatedXmaxPosition[0],RotatedXmaxPosition[1],"Xmax")
            
            circle2 = plt.Circle((Xc, Yc), siteradius, color = 'green',alpha = 0.25)
            
            ax1.add_patch(circle2) 
            #plt.show()

        #################################

        print("about to do interpolation on:"+str(OutputFileName))

        #do_interpolation_hdf5(RotatedDesPos.T, InputFileName, OutputFileName, antennamin = 0, antennamax = 159, EventNumber = 0,shower_core = np.array([0,0,2900]), DISPLAY = DISPLAY, usetrace = usetrace)
        #we now store the core position, and modify the azimuth, and rotate the antenna to the correct coordinates and select antntenas above threshold inside
        do_interpolation_hdf5(RotatedDesPos, InputFileName, OutputFileName, antennamin = 0, antennamax = 159, EventNumber = 0,DISPLAY = DISPLAY, usetrace = usetrace,overridecoreposition = RandomCoreFTP,overrideazimuth = EmulatedAzimuth,savetraces = SAVETRACES,minefield = minefield,minvoltage = minvoltage,StatisticalWeight = weight)        

        #store tested positions (all are the same EmulatedAzimuth)
        RecoRunInfo = hdf5io.GetRunInfo(OutputFileName)
        RecoEventName = hdf5io.GetEventName(RecoRunInfo,0) #using the first event of each file (there is only one for now)
        SampledArea = 3*np.sqrt(3)*step*step/2 #area of the exagon of side step)
        CoresTested = np.array(CoresTested)
        ProbedCoresTable = hdf5io.CreateProbedCoresTable(CoresTested, RecoEventName, 0, SampledArea,info = {})
        hdf5io.SaveProbedCoresTable(OutputFileName,RecoEventName,ProbedCoresTable)

        ReadCoresTable = hdf5io.GetProbedCoresTable(OutputFileName,RecoEventName)
                
        #plot the output for comparison
        if(DISPLAY):        
            #get basic showerinfo we will output to the showerinfo file
 
            RecoEventInfo = hdf5io.GetEventInfo(OutputFileName,RecoEventName)
            RecoAntennaInfo = hdf5io.GetAntennaInfo(OutputFileName,RecoEventName)
            RecoAntennaP2PInfo = hdf5io.GetAntennaP2PInfo(OutputFileName,RecoEventName)          

            fig2 = plt.figure(2,figsize = (width,height), facecolor = 'w', edgecolor = 'k')
            ax1 = fig2.add_subplot(111)
            ax1.scatter(DesXCC,DesYCC,s = 150,alpha = 0.20)
            ax1.scatter(RotatedStshpX[0:160],RotatedStshpY[0:160],c = np.log10(PeakV[0:160]),cmap = plt.cm.jet,vmin = np.log10(minvoltage),vmax = np.log10(np.max(PeakV[0:160])),alpha = 0.75)
            
            ax1.scatter(0,0,c = "black",label = "Core")        
            ax1.text(0,0,"Core")
            
            ax1.plot([0,10000*np.cos((EmulatedAzimuth-180)*np.pi/180)],[0,10000*np.sin((EmulatedAzimuth-180)*np.pi/180)],'b')
            
            ax1.set_xlabel("X core centered coordinates [m] ")
            ax1.set_ylabel("Y core centered coordinates [m] ")
            
            ax1.scatter(Xp,Yp,color = 'Black',label = "FTP")
            ax1.text(Xp,Yp,"FTP")

            ax1.scatter(Xc,Yc,color = 'Black',label = "FTP")
            ax1.text(Xc,Yc,"Center")

            ax1.scatter(RotatedXmaxPosition[0],RotatedXmaxPosition[1],c = 'black')
            ax1.text(RotatedXmaxPosition[0],RotatedXmaxPosition[1],"Xmax")
            
            circle2 = plt.Circle((Xc, Yc), siteradius, color = 'green',alpha = 0.10)
            circle1 = plt.Circle((Xc, Yc), step, color = 'green',alpha = 0.10)
            
            ax1.add_patch(circle2)
            ax1.add_patch(circle1) 

            RecoX = hdf5io.GetXFromAntennaInfo(RecoAntennaInfo)
            RecoY = hdf5io.GetYFromAntennaInfo(RecoAntennaInfo)
            RecoZ = hdf5io.GetZFromAntennaInfo(RecoAntennaInfo)
    
            RecoPeakE = hdf5io.GetHilbertPeakEFromAntennaP2PInfo(RecoAntennaP2PInfo)
            RecoPeakV = hdf5io.GetHilbertPeakVFromAntennaP2PInfo(RecoAntennaP2PInfo)
            RecoPeakE = RecoPeakE.data
            RecoPeakV = RecoPeakV.data #to make it an array              
            
            im = ax1.scatter(RecoX,RecoY,c = np.log10(RecoPeakV[0:160]),cmap = plt.cm.jet,vmin = np.log10(minvoltage),vmax = np.log10(np.max(PeakV[0:160])),s = 200)            
            #print("recopeak",RecoPeakV)
            bar = fig2.colorbar(im,ax = ax1)
            bar.set_label('$log_{10}$(Signal[$\mu$V/m])', rotation = 270, labelpad = 17)
            
            im = ax1.scatter(CoresTested[:,0]-CoresTested[-1,0],CoresTested[:,1]-CoresTested[-1,1],color = "Red",alpha = 0.25) #the cores in the reference of the core
            
            plt.show()
            
        if(reconstructiontrace =  = "efield"):
          recothreshold = minefield
        elif(reconstructiontrace =  = "voltage"):
          recothreshold = minvoltage

        if(RECONSTRUCT>0): #get the data
            #cmd = 'python3 /home/mjtueros/GRAND/LayoutStudy/GridShapeKewen/Recontruction/mod_recons_tools.py '+OutputFileName+' '+OutputDir
            cmd = 'python3 /home/mjtueros/GRAND/LayoutStudy/GridShapeKewen/Recontruction/PrepareReconstruction.py '+OutputFileName+' '+OutputDir+' '+str(antennathreshold)+' '+str(recothreshold)+' '+reconstructiontrace

            print(cmd)

            out = subprocess.Popen(cmd,
               stdout = subprocess.PIPE,
               stderr = subprocess.PIPE,
               shell = True)
            stdout,stderr = out.communicate()
            print("stdout")
            print(stdout)
            print("sterr")            
            print(stderr)

            shower_file = OutputDir+'/shower_parameters.txt'
            coinc_file = OutputDir+"/Rec_coinctable.txt"
            antcoord_file = OutputDir+"/coord_antennas.txt"
            EventName, Azimuth, Zenith, Energy, Primary, XmaxDistance, SlantXmax, x_Xmax, y_Xmax, z_Xmax, AntennasNumber, planeref = np.loadtxt(shower_file).T
            
            RunName =  CurrentEventName + ".Interpolated."+gridtype+"_"+"_"+str(usetrace)+"_"+str(EmulatedAzimuth)
            GeoRecoRefMeta = hdf5io.CreateGeoRecoRefMeta(RunName,RecoEventName)            
            GeoRecoRef = hdf5io.CreateGeoRecoRef(RecoEventName, Azimuth, Zenith, Energy, Primary, XmaxDistance, SlantXmax, x_Xmax, y_Xmax, z_Xmax, AntennasNumber, planeref,GeoRecoRefMeta)
            hdf5io.SaveGeoRecoRef(OutputFileName,RecoEventName,GeoRecoRef)
            
            print("Collected:",Zenith,Azimuth,"xmaxdist",XmaxDistance,x_Xmax,y_Xmax,z_Xmax,"na",AntennasNumber)

        if(RECONSTRUCT>0): #plane reconstruction
            if not os.path.exists(shower_file) : #the data collection failed, exit
              sys.exit(-1)
                        
            cmd = '/home/mjtueros/GRAND/LayoutStudy/GridShapeKewen/Recontruction/TREND_soft/bin/recons 0 '+OutputDir

            print(cmd)

            out = subprocess.Popen(cmd,
               stdout = subprocess.PIPE,
               stderr = subprocess.PIPE,
               shell = True)
            stdout,stderr = out.communicate()
            print("printing")
            print(stdout)
            print(stderr)

            plan_file = OutputDir+'/Rec_plane_wave_recons.txt'
            if not os.path.exists(plan_file) : #the reco failed, exit
              os.remove(shower_file)
              os.remove(coinc_file)
              os.remove(antcoord_file)
              sys.exit(-2)            
                        
            IDsRec, PlaneNa, PlaneZenithRec, PlaneZenithError, PlaneAzimuthRec, PlaneAzimuthError, PlaneChi2, PlaneChiSignif = np.loadtxt(plan_file).T
            PlaneRecoInfoMeta = hdf5io.CreatePlaneRecoInfoMeta(RunName,RecoEventName)            
            PlaneRecoInfo = hdf5io.CreatePlaneRecoInfo(IDsRec, PlaneNa, PlaneZenithRec, PlaneZenithError, PlaneAzimuthRec, PlaneAzimuthError, PlaneChi2, PlaneChiSignif,PlaneRecoInfoMeta)
            hdf5io.SavePlaneRecoInfo(OutputFileName,RecoEventName,PlaneRecoInfo)
            
            print("PlaneReco:",PlaneZenithRec,"+/-",PlaneZenithError,PlaneAzimuthRec,"+/-",PlaneAzimuthError,PlaneChi2,PlaneChiSignif)
                        
        if(RECONSTRUCT>1):
             
            cmd = '/home/mjtueros/GRAND/LayoutStudy/GridShapeKewen/Recontruction/TREND_soft/bin/recons 1 '+OutputDir

            print(cmd)

            out = subprocess.Popen(cmd,
               stdout = subprocess.PIPE,
               stderr = subprocess.PIPE,
               shell = True)
            stdout,stderr = out.communicate()
            print("printing")
            print(stdout)
            print(stderr)

            sphere_file = OutputDir+'/Rec_sphere_wave_recons.txt'
            if not os.path.exists(sphere_file) : #the reco failed, exit
              os.remove(plan_file)
              os.remove(shower_file)
              os.remove(coinc_file)
              os.remove(antcoord_file)              
              sys.exit(-3)            

            IDsRec, SphereNa, SphereChi2, SphereChiSignif, XSourceRec, YSourceRec, ZSourceRec, TSourceRec = np.loadtxt(sphere_file).T    
            SphereRecoInfoMeta = hdf5io.CreateSphereRecoInfoMeta(RunName,RecoEventName)            
            SphereRecoInfo = hdf5io.CreateSphereRecoInfo(IDsRec, SphereNa, SphereChi2, SphereChiSignif, XSourceRec, YSourceRec, ZSourceRec, TSourceRec,SphereRecoInfoMeta)
            hdf5io.SaveSphereRecoInfo(OutputFileName,RecoEventName,SphereRecoInfo)
            print("Sphere",XSourceRec,YSourceRec,ZSourceRec,TSourceRec,SphereChi2,SphereChiSignif)

        if(RECONSTRUCT>2):
            cmd = '/home/mjtueros/GRAND/LayoutStudy/GridShapeKewen/Recontruction/TREND_soft/bin/recons 2 '+OutputDir

            print(cmd)

            out = subprocess.Popen(cmd,
               stdout = subprocess.PIPE,
               stderr = subprocess.PIPE,
               shell = True)
            stdout,stderr = out.communicate()
            print("printing")
            print(stdout)
            print(stderr)


            adf_file = OutputDir+'/Rec_adf_recons.txt'

            if not os.path.exists(adf_file) : #the reco failed, exit
              os.remove(sphere_file)
              os.remove(plan_file)
              os.remove(shower_file)
              os.remove(coinc_file)
              os.remove(antcoord_file)
              sys.exit(-4)                

            IDsRec, ADFNa, ADFZenithRec, ADFZenithError, ADFAzimuthRec, ADFAzimuthError, ADFChi2, ADFChiSignif, WidthRec, AmpRec = np.loadtxt(adf_file).T
            ADFRecoInfoMeta = hdf5io.CreateADFRecoInfoMeta(RunName,RecoEventName)            
            ADFRecoInfo = hdf5io.CreateADFRecoInfo(IDsRec, ADFNa, ADFZenithRec, ADFZenithError, ADFAzimuthRec, ADFAzimuthError, ADFChi2, ADFChiSignif, WidthRec, AmpRec,ADFRecoInfoMeta)
            hdf5io.SaveADFRecoInfo(OutputFileName,RecoEventName,ADFRecoInfo)
            print("ADF Reco",ADFZenithRec,"+/-", ADFZenithError, ADFAzimuthRec,"+/-", ADFAzimuthError,"Chi2",ADFChi2,ADFChiSignif,WidthRec,AmpRec)     

        if os.path.exists(adf_file) :
          os.remove(adf_file)
        if os.path.exists(sphere_file) :
          os.remove(sphere_file)
        if os.path.exists(plan_file) :
          os.remove(plan_file)
        if os.path.exists(shower_file) :
          os.remove(shower_file)
        if os.path.exists(coinc_file) :
          os.remove(coinc_file)
        if os.path.exists(antcoord_file) :
          os.remove(antcoord_file)

        if(OLDOUTPUT):#this was the old output

            if(usetrace =  = "all"):
              print("usetrace is all, looping over all trace types")
              usetracelist = ["efield","voltage","filteredvoltage"]
            else:
              usetracelist = [str(usetrace)]
            for tracetype in usetracelist:
              print("getting p2p info for:"+tracetype)

              P2PFile = OutputDir+"/"+InputJobName + ".Interpolated."+gridtype+"_"+str(step)+"_"+str(tracetype)+"_"+str(EmulatedAzimuth)+".P2Pdat"

              #if the P2Pdat is there, the thing has already been done probabbly, and we should get out of here
              if os.path.isfile(P2PFile):
                print(P2PFile+" already exists, skipping")
                return

              #now i have to complete with 0 the antennas of the array that where not interpolated, so that the output is easier to use
              OutRunInfo = hdf5io.GetRunInfo(OutputFileName)
              OutEventName = hdf5io.GetEventName(OutRunInfo,0)
              OutAntennaInfo = hdf5io.GetAntennaInfo(OutputFileName,OutEventName)
              OutIDs = hdf5io.GetAntIDFromAntennaInfo(OutAntennaInfo)
              OutAntennaP2PInfo = hdf5io.GetAntennaP2PInfo(OutputFileName,OutEventName)

              #p2p_out = hdf5io.get_p2p_hdf5(OutputFileName,usetrace = tracetype)

              if(tracetype =  = "efield"):
                p2p = hdf5io.GetP2P_efieldFromAntennaP2PInfo(OutAntennaP2PInfo)
                p2px = hdf5io.GetP2Px_efieldFromAntennaP2PInfo(OutAntennaP2PInfo)
                p2py = hdf5io.GetP2Py_efieldFromAntennaP2PInfo(OutAntennaP2PInfo)
                p2pz = hdf5io.GetP2Pz_efieldFromAntennaP2PInfo(OutAntennaP2PInfo)
              if(tracetype =  = "voltage"):
                p2p = hdf5io.GetP2P_voltageFromAntennaP2PInfo(OutAntennaP2PInfo)
                p2px = hdf5io.GetP2Px_voltageFromAntennaP2PInfo(OutAntennaP2PInfo)
                p2py = hdf5io.GetP2Py_voltageFromAntennaP2PInfo(OutAntennaP2PInfo)
                p2pz = hdf5io.GetP2Pz_voltageFromAntennaP2PInfo(OutAntennaP2PInfo)
              if(tracetype =  = "filteredvoltage"):
                p2p = hdf5io.GetP2P_filteredFromAntennaP2PInfo(OutAntennaP2PInfo)
                p2px = hdf5io.GetP2Px_filteredFromAntennaP2PInfo(OutAntennaP2PInfo)
                p2py = hdf5io.GetP2Py_filteredFromAntennaP2PInfo(OutAntennaP2PInfo)
                p2pz = hdf5io.GetP2Pz_filteredFromAntennaP2PInfo(OutAntennaP2PInfo)

              p2p_out = np.stack((p2px, p2py, p2pz, p2p), axis = 0)

              #now, i complete with 0 to
              p2p_total_new = np.zeros((4,len(RotatedDesPos)))
              index = 0
              for i in OutIDs:
                p2p_total_new[0,int(i)] = p2p_out[0,index]
                p2p_total_new[1,int(i)] = p2p_out[1,index]
                p2p_total_new[2,int(i)] = p2p_out[2,index]
                p2p_total_new[3,int(i)] = p2p_out[3,index]
                index = index+1

              #fig3a = plt.figure()
              #ax3a = fig3a.add_subplot(1,1,1)
              #im = ax3a.scatter(DesX,DesY,c = p2p_total_new[3],cmap = plt.cm.jet,vmin = np.min(P2P[0:160]),vmax = np.max(P2P[0:160]))
              #im = ax3a.scatter(StshpX[0:160],StshpY[0:160],c = P2P[0:160],cmap = plt.cm.jet,vmin = np.min(P2P[0:160]),vmax = np.max(P2P[0:160]))
              #bar = fig3a.colorbar(im,ax = ax3a)
              #plt.show()

              # write antenna trigger information file (this would be cool to have it also inside the interpolated hdf5)
              np.savetxt(P2PFile, p2p_total_new,fmt = '%1.4e')

              FILE = open(P2PFile+str(".showerinfo"),"w" )
              print("%s %s %1.5e %1.5e %1.5e %1.5e %1.5e %1.5e %1.5e %1.5e %s" % (InputJobName,Primary,Energy,Zenith,Azimuth,XmaxDistance,SlantXmax,RandomCore[0],RandomCore[1],RandomAzimuth,HadronicModel), file = FILE)
              FILE.close()

        print("done with "+str(case))
        
        #now, lets produce the 
        

    print("done with all configurations")
    #here i could clean the files i dont want to keep:
    #in this case, i will delete all the hdf5 files, becouse they take too much space and i dont have any use for them for now
    #for name in glob.glob(OutputDir+"/"+InputJobName + ".Interpolated.*.hdf5"):
    #  os.remove(name)





def main():

    if (len(sys.argv)<3):
        print("""
            Usage: python3 thisfile.py inputdirectory outputdirectory
        """)
        sys.exit(0)

    InputDir = sys.argv[1]
    OutputDir = sys.argv[2]

    configurations = [
        ["trihex", 125], ["hexhex", 125], ["rect", 137.5],
        ["trihex", 250], ["hexhex", 250], ["rect", 275],
        ["trihex", 500], ["hexhex", 500], ["rect", 500],
        ["trihex", 750], ["hexhex", 750], ["rect", 825],
        ["trihex", 1000], ["hexhex", 1000], ["rect", 1100]
    ]

    #configurations = [["trihex",125],["hexhex",125],["rect",137.5]]
    #configurations = [["trihex",125,10],["hexhex",500,4],["hexhex",125,4]]
    #Test for kumiko
    # configurations = [["trihex",125,4],["hexhex",125,4]]
    #Run for kumiko
    #configurations = [["trihex",250,20]]
    #Run for Kewewn
    configurations = [["fromfile", 3, 0]] #use file, extra radius of 3mts (needs to be bigger than 2) (the second 0 is not used at all)
    configurations = [["GP100", 3, 0]] #use file, (the second and 3rd parameters is not used at all)
    


    # check triggers (lets see if we can merge this calls)
    grid_study_on_starshape_hdf5(InputDir, OutputDir, configurations, usetrace = 'all')

    #grid_study_on_starshape_hdf5(InputDir, OutputDir, configurations, usetrace = 'efield')

    #grid_study_on_starshape_hdf5(InputDir, OutputDir, configurations,  usetrace = 'voltage')
    

print(__name__)
if __name__ = =  '__main__':
    main()
